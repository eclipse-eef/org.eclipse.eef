<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="RuntimeCoreConcepts">Runtime Core Concepts</h1><h2 id="EditingContext">Editing Context</h2><p>One of the main concept of EEF Runtime is the <strong>Editing Context</strong>. An editing context has two roles:</p><ul><li>Bringing all data necessary for a EMF model editing (<code>AdapterFactory</code>, <code>EditingDomain</code>, ...)</li><li>Providing the <strong>EEF Editing policies</strong>  to controllers (see <em>Editing Policies</em>)</li></ul><h3 id="ContextsHierarchy">Contexts Hierarchy</h3><p><img border="0" src="../../pics/Runtime - Core - Context Hierarchy.png"/> </p><p>The root context of the EEF Runtime is the <code>EObjectPropertiesEditingContext</code>. This editing context, focused on one <code>EObject</code>, keep track of </p><ul><li>the edited element</li><li>the <code>AdapterFactory</code> to use in this context</li><li>and the EEF options (see <i>Context Options</i>)</li></ul><p>This context store also a @ChangeRecorder@s, this object keep track of all modifications done during the editing session. It permits to undo these modifications when the user require this action.</p><p>Deriving this context, the <code>DomainPropertiesEditingContext</code> store the <code>EditingDomain</code> to use in order to perform EMF commands.</p><p>Some editing contexts are derived from an utility context, the <code>DelegatingPropertiesEditingContext</code>. This one simply delegates all method calls to the context which it is associated. <br/>The <code>SemanticPropertiesEditingContext</code> is a one of these contexts. It stores a EEF <strong>Editing Event</strong> for editing policies purpose (see <i>Editing Policies</i>). </p><h3 id="ContextOptions">Context Options</h3><p>An editing context can be configured by several options defined in a <code>ContextOptions</code> object. Options avaiblable are:</p><ul><li><em>Auto-wiring</em>: This option defines is a EEF component should try to automatically bind the properties of the edited <code>EObject</code> with the field of the handled view (see <em>Model Binding</em>).</li><li>Editing Validation: This option defines if a EEF component should validate the edited <code>EObject</code> when the component changes one of its properties.</li><li>Properties Change Delay: This option defines the delay before a component change an <code>EObject</code> properties when the <em>Delayed Properties Editing</em> is actived (see <em>Model Binding</em>).</li></ul><p>In addition of these options, a <em>ContextOptions</em> stores a map of options accessible via the methods <code>setOption : String x Object -&gt; void</code> and <code>getOption : String -&gt; Object</code></p><h2 id="EditingPolicies">Editing Policies</h2><p>Editing operations in EEF are defined by <strong>Editing Policies</strong>. The way to obtain an <strong>Editing Policy</strong>  is to ask this one to an <strong>Editing Context</strong> with the same or another context describing the editing operation to perform. Like the <strong>Editing Context</strong>, the EEF core runtime provides a initial policies hierarchy for the default editing operations.</p><h3 id="PoliciesHierarchy">Policies Hierarchy</h3><p><img border="0" src="../../pics/Runtime - Core - Policies Hierarchy.png"/> </p><p>The <code>SemanticEditingPolicies</code> are used to edit a structural feature of an <code>EObject</code>. These policies set a value to a given feature. The <code>SemanticEditingPolicy</code> class is abstract because there is two ways to edit an <code>EObject</code> and these two ways are implemented by two subclasses of the <code>SemanticEditingPolicy</code>:</p><ul><li>EEF can directly modify the values of a given <code>EObject</code> (using setters of this object) via a <code>SemanticDirectEditingPolicy</code>. A <code>SemanticDirectEditingPolicy</code> is returned on asking a <code>PropertiesEditingPolicy</code> to a <code>EObjectPropertiesEditingContext</code> with a <code>SemanticPropertiesEditingContext</code>.  </li><li>EEF can modify an <em>EObject</em>  using EMF commands via a <code>SemanticDomainEditingPolicy</code>. A <code>SemanticDomainEditingPolicy</code> is returned on asking a <code>PropertiesEditingPolicy</code> to a <code>DomainPropertiesEditingContext</code> with a <code>SemanticPropertiesEditingContext</code>.  </li></ul><h2 id="EEFNotifying">EEF Notifying</h2><h3 id="Communicationbetweenviewsandcontrollers">Communication between views and controllers </h3><p>The communication between views and controllers is managed by the EEF Notification system. A controller can process changes made in a view iif it receives <code>PropertiesEditingEvents</code>. This events describe the changes made in a view and are interpreted by the controllers to modify the EMF model.</p><p>To listen <code>PropertiesEditingEvents</code>, EEF provides as interface : <code>PropertiesEditingListener</code>. Basically, <code>PropertiesEditingComponents</code> (see <em>Model Binding</em>) are <code>PropertiesEditingListeners</code>. The <code>PropertiesEditingEvents</code> received by <code>PropertiesEditingListeners</code> are propagated by those so, it&#8217;s possible for EEF users to develop theirs own <code>PropertiesEditingListeners</code> in order to be notified of view changes.    </p><p>Two <code>PropertiesEditingEvent</code> implementations ara available in EEF runtime:</p><ul><li><code>PropertiesEditingEventImpl</code>: a basic <code>PropertiesEditingEvent</code> implementation</li><li><code>PropertiesValidationEditingEvent</code>: this event propagates the result on an <em>EMF validation</em> into the EEF notification system. These event are use to provides the EEF live editing validation mechanism. </li></ul><h3 id="StandardPropertyChangeSupportadaptation">Standard <em>Property Change Support</em> adaptation</h3><p>A standard notification system is available on the java beans : <em>Property Change Support</em>. EEF can handle views if their implement this system. This implies that the view changes must be notified to its listeners by sending <code>PropertyChangedEvents</code>. The EEF runtime provides some utilities to extend this mechanism and to make it easier to use. </p><p>First, EEF provides a <code>TypedPropertyChangedEvent</code> that let user specify the kind of change that have be done in the view. Indeed, a <code>PropertyChangedEvent</code> can only specify :</p><ul><li>The changed element</li><li>The property name</li><li>The old value</li><li>The new value</li></ul><p><code>TypedPropertyChangedEvent</code> let you defining the kind of change.</p><p>EEF alse provides a <code>ViewChangeNotifier</code> which is an <code>PropertyChangeListener</code> that converts <code>PropertyChangeEvents</code> into <code>PropertiesEditingEvents</code>. In case of EEF has to handle view implementing the <em>Property Change Support</em>, it adds a <code>ViewChangeNotifier</code> to the view in order to establish communication with  its <code>PropertiesEditingComponents</code>.</p><p><img border="0" src="../../pics/Runtime - Core - Notifying.png"/> </p><h2 id="Viewshandling">Views handling</h2><p>An extensible view management system is available in EEF Rutime to allow EMF object editing with any kind of view. This system defines the concept of <code>ViewHandler</code> to manage the view and to work with EEF controllers. A <code>ViewHandler</code> has two main roles:</p><ul><li>Creating the view when EEF need to display it to user</li><li>Update the view fields when the controller notify a model change</li></ul><p>The <code>ViewHandler</code> interfaces provides all methods necessary for this job:</p><pre>
public interface ViewHandler&lt;T&gt; {

	T createView(Object... args) throws ViewConstructionException;
		
	void initView(PropertiesEditingComponent component);

	void setValue(Object field, Object value) throws ViewHandlingException;

	void unsetValue(Object field) throws ViewHandlingException;
	
	void addValue(Object field, Object newValue) throws ViewHandlingException;

	void addAllValues(Object field, Collection&lt;?&gt; values) throws ViewHandlingException;

	void removeValue(Object field, Object value) throws ViewHandlingException;

	void removeAllValues(Object field, Collection&lt;?&gt; values) throws ViewHandlingException;

	void moveValue(Object field, Object value, int newIndex) throws ViewHandlingException;

}

</pre><p>EEF uses <code>ViewHandlerProvider</code> to associate a <code>ViewHandler</code> to a given kind of object. A <code>ViewHandlerProvider</code> determines if a view can be handle by its kind of <code>ViewHandler</code> and instantiates it when needed.  </p><h2 id="ModelBinding">Model Binding </h2><p>The binding of the view with the model is performed by the <code>PropertiesEditingComponents</code>. This element has three roles:</p><ul><li>Providing all the needed <em>ViewHandlers</em> for the edited element. The component keeps track of this handler for its tasks needing views management.</li><li>Updating the view when the edited model is modified. This is done regarding the <em>ViewHandlers</em> already provided by the component.</li><li>Updating the model when the views have changed.</li><li>Ensure editing validation when the option is set (see <em>Context Options</em>).</li></ul><h3 id="ModelUpdating">Model Updating</h3><p>The model updating can be performed in two mode. The standard mode is a &#171;real-time&#187; updating, when the component received a notification from a view, this modification is interpreted as a modification to perform on the edited model and is immediately applied. <br/>A second mode is available in EEF, the delayed mode. This mode has the same process that the real-time mode but instead of immediately applied the model change, EEF wait a delay. This delay can be defined in the options of the <code>PropertiesEditingContext</code> (see <em>Context Options</em>). To apply a change in the delay mode, the delayed mode option must be passed in the <code>PropertiesEditingEvent</code> constructor.</p><h3 id="Autowiringstrategy">Auto-wiring strategy</h3><p>TODO</p><h2 id="ThePropertiesEditingProvider">The <code>PropertiesEditingProvider</code></h2><p>The <code>PropertiesEditingProvider</code> is an EMF <code>AdapterFactory</code> responsible for providing the <code>PropertiesEditingComponents</code> for EMF edited objects. To do that, the <code>PropertiesEditingProvider</code> bring the <em>Editing Models</em> available for EEF (editing models are the EEF models describing the UI and the binding for given EMF models) and the <em>View Handlers</em> available in EEF to interpret the views provided by the users.</p><p>The <code>PropertiesEditingProvider</code> provides two methods in order to add specific <em>Editing Models</em> or specific <em>View Handlers</em>. These methods can be use to change the default behavior of EEF. The specific element provided by these methods are evaluated before the standard models and handlers.</p><pre>
public class PropertiesEditingProvider extends AdapterFactoryImpl implements AdapterFactory {

	...

	protected Collection&lt;? extends PropertiesEditingModel&gt; initSpecificEditingModel();

	protected ViewHandlerProvider initViewHandlerProvider():

}

p.


</pre></body></html>